---
title: "Reproducible Programming in R Practical 2-2"
output:
  learnr::tutorial:
    theme: lumen
runtime: shiny_prerendered
description: "Reproducible Programming in R Practical 2-2!"
---

```{r setup, include=FALSE}
library(learnr)

knitr::opts_chunk$set(error = TRUE)
set.seed(123)
```


## Overview

*In this session you will break the program 0201-growth-loop.r into two conceptually distinct parts – moving the code implementing how the population behaves into a function, thus separating it from the mechanics of running the simulation and plotting the results.*

## Background

When we look at our first program – 
<span style="color: #de77ae;">0201-growth-loop.r</span> – there are several
distinct parts to the code, despite its brevity. We first set the initial 
conditions of the simulation, then we run the simulation itself, and finally we 
plot the output. Inside the simulation, we have the mechanics of iterating over 
the timesteps and keeping track of the results, and there is the implementation 
of the growth model itself, which occurs inside the curly brackets. Obviously in 
this case none of these four steps are very complex (and you indeed might decide 
there are fewer – or even more – that are actually important), but as we develop 
more complex models some or all of them will become more complicated, and if 
they are all written out in one continuous piece of code it will become harder 
and harder to work out where one part ends and another begins, and how we need 
to change the code if we want, for instance, to change the underlying model of 
population growth, but not change the technique used for simulation or the plots 
produced, in the same way as you might wish this paragraph had been broken into
sentences instead of running on seemingly for ever!

What we need to do is to introduce exactly the computing equivalent of 
punctuation and sentence/paragraph structure into the code. We introduce this 
partly by commenting the code well, which we have already started to do, but 
mostly by separating out conceptually distinct parts of the code into separate 
functions. This process will continue through the whole course as we identify 
reusable pieces of code that we can get right once, and then (hopefully) never 
have to worry about again. This often turns out to be more of an aspiration than 
reality, but nonetheless, when we do want to improve specific parts of our 
models, it is much easier to do it when the code is well structured.

## Tasks

Look at the code from the last practical. The code in the for loop, that is to 
say inside the curly brackets, describes the way that the population changes 
from one point in time to the next. This (together with, perhaps, the starting 
conditions) is what we would be changing if we wanted to explicitly introduce 
birth and death into the model, or make it a model of disease spread rather than 
population growth. The rest would remain pretty much the same.

We want to take this code and put it into its own function at the beginning of 
the program (we call it `step_simple_growth()` in our version). It should take 
the current population count from the vector `population.vector`, and the value 
of `growth.rate` as inputs – they are called arguments – update the population 
size and return it. This is the framework for such a function with comments 
(replace `# -- some arguments --` with working code):

```{r}
#' ### Function: step_simple_growth() 
#'
#' Run one step of a simple deterministic exponential growth model. 
#'
#' Arguments: 
#'
#' - current.population -- the population count now
#' - growth.rate -- the growth rate 
#'
#' Returns:
#'
#' - the updated population count
step_simple_growth <- function(current.population, growth.rate)
{
  # Calculate changes to population
  new.additions <- # -- some arguments --
    next.population <- # -- some arguments --
    # Return updated population
    next.population
}
```
The `function()` command, like `for()`, has one line of code after it (comments 
are ignored) that defines what the function does. Because nearly all functions 
need multiple lines to define what they do, we nearly always use `{ ... }` 
syntax (as with `for()`) to allow us to write multiple commands all as part of 
the function definition. Remember that whatever appears last in the function 
definition will be returned to script that calls it, in this case 
`next.population`. Again, you can click on the little triangle to the left of 
the opening bracket a couple of times to check that the right bit is in the 
function definition, or you can select all of the code, and reindent it.

To make sure that the function is only using the information given to it in its 
arguments, we are going to use `findGlobals()` to check that it does not use any 
external information (such information is called global variables). To do this 
we load in the codetools library (you may have to install it first), and then 
call the `findGlobals()` function giving it the name of our function, as 
follows:

```{r}
library(codetools) 
findGlobals(step_simple_growth, merge=FALSE)
```

This will return some built in functionality of R which your function uses under 
“functions”, and then hopefully nothing under variables (it actually says 
character(0) if you have succeeded – obscurely!). Next note that the variable 
names `new.additions` and `next.population` remains internal to the function 
`step_simple_growth()`. We could call them `louise.matthews` and `richard.reeve` 
rather than `next.population` if we wanted. What is important is the name that 
we assign to the output of the function in the main script, which in this case 
is also `next.population`. You may find this reuse of names slightly confusing. 
So do we. Bear with us, though – we will stop doing it at the end of this 
practical.

Having now defined the function, the code should proceed much as 
<span style="color: #de77ae;">0201-growth-loop.r</span> but rather than have a 
chunk of code inside the loop we can just assign the `next.population` variable 
to the output of the function `step_simple_growth()`.

Within the `for()` loop where the time gets updated the code will now contain 
the line:

```{r}
next.population <- step_simple_growth(current.population = tail(population.vector, 1), 
                                      growth.rate = growth.rate)
```

`current.population` is now an argument of the `step_simple_growth()` function, 
and so you set its value using `=` inside the function call instead of using 
`<-` in the main script as you did in 1-1, growth.rate is both an argument of 
the function and a variable in the main script, so we ended up setting one to 
the other rather confusingly with `growth.rate=growth.rate`. As we said above, 
we will fix this later to make it look a bit less strange! Note, that we always 
set arguments to functions with `argument=value`, and we strongly recommend 
using `variable <- value` to set variables in your code to make the distinction 
clear. We’ve now replaced the first three lines of code in the `for()` loop with 
that one line, but there’s still one line remaining from 1-1: we still haven’t 
updated the population vector itself, so we now need to update it (still inside 
the loop, as before):

```{r}
population.vector <- append(population.vector, next.population)
```

Using your first program <span style="color: #de77ae;">0201-growth-loop.r
</span>, try to create this new code, <span style="color: #de77ae;">
0202-growth-functional.r</span>.

## Running the code

You can either compare the values of `population` or the plotted outputs of 
<span style="color: #de77ae;">0201-growth-loop.r</span> and the new 
<span style="color: #de77ae;">0202-growth-functional.r</span> to check that 
your new code works exactly as the old. <span style="color: #de77ae;">
0202-growth-functional.r</span> does exactly what the 
<span style="color: #de77ae;">0201-growth-loop.r</span> did but is structured 
in a better style.

## Names of arguments to functions

When you are happy with the code and its outputs there is another task. If you 
look at the whole code, you will see that `growth.rate` is both the name of the
argument in the function and the name of the variable in the script, and
`next.population` is used in the function and in the main script. As we said 
above, this does not have to be the case and can be confusing.

Copy the <span style="color: #de77ae;">0202-growth-functional.r</span> file 
which contains the new function and code and save it somewhere else. We’re going 
to edit this new file to show what changes don’t matter, and then we’re going to 
delete the file, so 
**be sure you’ve copied the file before you start messing with it**. Open the 
new file and use the Find... option in RStudio to find all the instances of
`growth.rate` and replace them with `rate1` in the `step_simple_growth()` 
function **but not in the script that follows**. Save the file and rerun the 
whole file in the usual way. What happens? It should not work, and it will tell 
you that you have an unused argument, `growth.rate` when you call
`step_simple_growth()`. This is because when you call the function, you set its
argument called growth.rate to the script’s value of growth.rate, but the 
function now only has an argument called `rate1`. Change the call to
`step_simple_growth()` to say `rate1=growth.rate`, and now rerun it. It should 
now run identically to before.

Now do the same with `next.population`, replacing it **just in the function** 
with `my.value`, or anything, `frogs`, `water`, etc. Save the file and rerun it. 
What happens? You should find that the model runs exactly as before this time. 
This is because none of the names of variables being used in the function matter 
– even if their values are being given back (we say **returned**) to the main 
script. The only thing that matters is that they are used consistently within 
the function, and when you call the function in the main script. Those names and 
their values are thrown away when the function finishes. Only the variables in 
the main script are retained. **You should now discard this file and go back to the original file for the rest of the exercise.**

We need to use meaningful names to remind us what we are doing, but it can be 
confusing and cause subtle errors if we use the same variable names in many 
different places, even when they seem to refer to the same things. This is one 
of the reasons why we use `findGlobals()` to check for global variables being 
used in functions. If we never reused names in different bits of code we would 
not have to check this. For the time being (and the rest of practical 1), make 
sure that no argument names in the main script accidentally match names in 
functions (it’s okay for variable names in different functions to match). You 
can relax this requirement in the real world, but it is best to be over-cautious 
for the time being.

For this practical, we are working with the human population in the script, so 
change the `growth.rate` variable in the main script of 
<span style="color: #de77ae;">0202-growth-functional.r</span> to
`human.annual.growth`, and change `next.population` in the main script to
`updated.human.population`. Then rerun the report. This is the code and report 
that should be submitted.

## Report

Generate a report by generating a notebook from the script you have written and 
check the results are the same as for 2-1.
