---
title: "Reproducible Programming in R Practical 4-1"
output: 
  learnr::tutorial:
    theme: lumen
runtime: shiny_prerendered
description: "Reproducible Programming in R Practical 4-1!"
---

```{r setup, include=FALSE}
library(learnr)

knitr::opts_chunk$set(error = TRUE)
set.seed(123)
```

## Overview

*In this practical we will run our first stochastic simulations, starting with the stochastic version of the population growth model. From now on, we will expect a brief report in some format on every practical, so we will not give explicit guidance in every case.*

## Background

In the lecture, we discussed the fact that the deterministic models that we have
been using so far so do not handle dynamics at the individual level well. To 
capture individual-level behaviour we need to include an element of chance in
the model. This new type of model, which includes a probabilistic element, is 
called a stochastic model.

## Tasks

To write a model to handle stochastic population dynamics we obviously have to 
update the timestep function to handle the new dynamics. However, we also have 
to understand whether anything else has changed in how the simulation works. In
fact, it has. There is now the chance that the population will die out before 
the end of the experiment, so we need to look for this happening – not least to 
speed up the simulation.

We’ll start by writing the structural code (in **0401-run-birth-death.r**). From
Practicals 3-3 and 3-4 we have a `while()` loop which runs the simulation 
(remember that we are back to the birth-death population dynamics from 2-5 
though):

```{r}
while (latest.population$time < end.time) {
  latest.population <- timestep_deterministic_SIR(
    # -- some arguments --
  ) 
  population.df <- rbind(population.df, latest.population)
}
```

The loop ends when the time runs out. Now, instead, there are two reasons why we
might stop the simulation – the time may have run out, or the timestep code may
identify that the dynamics are now complete. To achieve this, the timestep code 
will have to return both the updated population and whether the simulation is
over. We suggest doing something like this:

```{r}
while (keep.going) {
  data <- timestep_stochastic_birth_death(
    # -- some arguments --
  ) 
  latest.population <- data$updated.pop
  population.df <- rbind(population.df, latest.population)
  ## The experiment may end stochastically or the time may run out 
  keep.going <- (!data$end.experiment) &&
    (latest.population$time < end.time)
}
```

Notice that at the start of the loop `keep.going` has not yet been defined, 
which will cause an error, so you will need to start it off with an appropriate
value. Now you will need to write the `timestep.stochastic.birth.death()` 
function (in **0401-stochastic-birth-death.r**) to provide the right information 
to the main loop.

We already have a deterministic step function for single species population 
dynamics from Practical 1- 5. Starting with this code, you need to make three 
changes. First, we need to handle the effect of changing timesteps and update
the code from practical 2-5 (or the code you produced for SIS and SIR models in
Practicals 3-3 and 3-4) with something like this:

Then we need to work out whether the simulation has ended and return both
pieces of information – the updated population and simulation state, by 
returning a list like this at the end of the function (since a function can only
return one item, we will have to return a list with two elements):

```{r}
timestep_stochastic_birth_death <- function(latest, birth.rate, death.rate, timestep) {
  effective.birth.rate <- birth.rate * timestep
  # -- some code to determine the numbers of new births and deaths --
  next.population <- data.frame(time = latest$time + timestep
                                #, -- some arguments --
  )
  # -- some code to calculate whether the experiment is finished --
  list(updated.pop = next.population, 
       end.experiment = is.finished) 
}
```

But we need to calculate whether the experiment is finished first – before the
end of the function! In this case, the experiment will only end if the
population completely dies out, so:

```{r}
is.finished <- the.number.of.individuals.left == 0
```

Finally, we need to make the simulation stochastic using `rbinom()`. Remember if 
you want to draw once from the binomial distribution with `count` trials, and a
probability of success of `prob`, then the number of successes is:

```{r}
new.events <- rbinom(1, count, prob)
```

So, the key is to use the `rbinom()` function to determine the numbers of new 
births and deaths each time step. The number of births is drawn from a binomial
distribution with size count, and probability `birth.rate * timestep`, and the
number of deaths from the same with probability `death.rate * timestep`.

## Running the code

When you are happy that the code is working and makes sense, **run the code**
several times without changing any parameters of initial conditions and look at
the output. The stochasticity means that we see variable outputs. If you don’t
it may be because your starting population is too high, try something much 
smaller, say 7 instead of 7 billion! You could also increase birth and death 
rates or the time you’re simulating over to increase visible variability.

Notice that (as before) we have repeated the piece of code doing the simulation
and have made use of the `new.graph = FALSE` option to overlay a second plot on 
the first.

If you haven’t already, try increasing the value of timestep. What happens? You
are actually getting impossible numbers (`NA`s) because the probability of
giving birth has got above 1. You can fix this by using the `stop()` command in
`timestep_stochastic_birth_death()` to stop running code when the numbers you 
put in are impossible:

```{r}
if ((effective.birth.rate >= 1) || (effective.death.rate >= 1))
  stop("Effective rate too high, timestep must be too big")
```

Rerun the code and check it stops when appropriate.

## Report

Produce a report shows the code working.
